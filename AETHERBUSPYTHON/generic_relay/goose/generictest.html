<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Generic Relay Tester</title>
    <style>
        body { font-family: monospace; margin: 0; padding: 0; display: flex; flex-direction: column; height: 100vh; background-color: #1a1a1a; color: #e0e0e0; }
        #header { padding: 10px; background-color: #2a2a2a; border-bottom: 1px solid #444; display: flex; align-items: center; }
        #header input { flex-grow: 1; margin-right: 10px; padding: 8px; background-color: #333; border: 1px solid #555; color: #e0e0e0; }
        #header button { padding: 8px 12px; cursor: pointer; background-color: #007acc; border: none; color: white; }
        #chat-log { flex-grow: 1; overflow-y: auto; padding: 10px; line-height: 1.6; }
        #input-area { display: flex; padding: 10px; border-top: 1px solid #444; }
        #message-input { 
            flex-grow: 1; 
            padding: 8px; 
            background-color: #333; 
            border: 1px solid #555; 
            color: #e0e0e0; 
            font-family: monospace;
            min-height: 60px;
        }
        .message { margin-bottom: 10px; }
        .message .source { font-weight: bold; }
        .message .source-user { color: #88ccee; }
        .message .source-agent { color: #ee9977; }
        .message .source-system { color: #cc6666; }
    </style>
</head>
<body>
    <div id="header">
        <input type="text" id="agent-name-input" placeholder="Enter Agent Name (e.g., Muse1)" value="GooseAgent">
        <button id="connect-btn">Connect</button>
    </div>
    <div id="status-bar" style="min-height:24px;padding:6px 10px;color:#ffea00;"></div>
    <div id="chat-log"></div>
    <div id="input-area">
        <textarea id="message-input" placeholder="Type a message..." rows="4" style="width: 100%; resize: vertical;" disabled></textarea>
    </div>

    <script>
        const agentNameInput = document.getElementById('agent-name-input');
        const connectBtn = document.getElementById('connect-btn');
        const chatLog = document.getElementById('chat-log');
        const messageInput = document.getElementById('message-input');

        let socket;
        let reconnectAttempts = 0;
        const MAX_RECONNECT_ATTEMPTS = 5;
        const RECONNECT_DELAY = 3000; // 3 seconds
        let isManualDisconnect = false;
        let reconnectTimeout;
        let pingInterval;

        function addLog(source, text, sourceClass = 'source-agent') {
            const msgDiv = document.createElement('div');
            msgDiv.className = 'message';
            msgDiv.innerHTML = `<span class="source ${sourceClass}">${source}:</span> ${text}`;
            chatLog.appendChild(msgDiv);
            chatLog.scrollTop = chatLog.scrollHeight;
        }

        function connect() {
            if (socket && (socket.readyState === WebSocket.CONNECTING || socket.readyState === WebSocket.OPEN)) {
                // Already connected or connecting
                if (socket.readyState === WebSocket.OPEN) {
                    addLog('System', 'Already connected!', 'source-system');
                }
                return;
            }

            const agentName = agentNameInput.value.trim();
            if (!agentName) {
                addLog('System', 'Please enter an agent name.', 'source-system');
                return;
            }

            // Clear any existing reconnect timeout
            if (reconnectTimeout) {
                clearTimeout(reconnectTimeout);
                reconnectTimeout = null;
            }

            // Clear any existing ping interval
            if (pingInterval) {
                clearInterval(pingInterval);
                pingInterval = null;
            }

            // Connect to the secure WebSocket server
            const relayUrl = `wss://vroll.evasworld.net/4011/chat/${agentName}`;
            //const relayUrl = `ws://localhost:4011/chat/${agentName}`;

            
            addLog('System', `Connecting to ${relayUrl}...`, 'source-system');
            
            try {
                socket = new WebSocket(relayUrl);
                isManualDisconnect = false;

                socket.onopen = () => {
                    addLog('System', 'Connection established!', 'source-system');
                    messageInput.disabled = false;
                    connectBtn.textContent = 'Disconnect';
                    reconnectAttempts = 0; // Reset reconnect attempts on successful connection
                    
                    // Start ping interval (every 20 seconds)
                    pingInterval = setInterval(() => {
                        if (socket && socket.readyState === WebSocket.OPEN) {
                            try {
                                socket.send(JSON.stringify({ type: 'ping' }));
                            } catch (e) {
                                console.error('Ping failed:', e);
                            }
                        }
                    }, 20000);
                };

                socket.onmessage = (event) => {
                    try {
                        const directive = JSON.parse(event.data);
                        
                        // Handle pong response
                        if (directive.type === 'pong') {
                            return; // Just ignore pong messages
                        }
                        
                        if (directive.directive_type === 'APPEND_TO_CHAT') {
                            addLog(directive.payload.source, directive.payload.text);
                        } else if (directive.directive_type === 'SHOW_PROCESSING_STATUS') {
                            const statusBar = document.getElementById('status-bar');
                            statusBar.textContent = directive.message || '';
                            
                            if (directive.status_type === 'progress') {
                                statusBar.style.color = '#ffea00';
                            } else if (directive.status_type === 'error') {
                                statusBar.style.color = '#ff5555';
                            } else {
                                statusBar.style.color = '#ffea00';
                            }
                            
                            if (directive.is_transient) {
                                setTimeout(() => { statusBar.textContent = ''; }, 3000);
                            }
                        } else {
                            console.log('Received unhandled directive:', directive);
                        }
                    } catch (e) {
                        console.error('Error processing message:', e, event.data);
                    }
                };

                socket.onclose = (event) => {
                    console.log('WebSocket closed:', event.code, event.reason);
                    messageInput.disabled = true;
                    connectBtn.textContent = 'Connect';
                    
                    // Clear ping interval
                    if (pingInterval) {
                        clearInterval(pingInterval);
                        pingInterval = null;
                    }
                    
                    // Only try to reconnect if the disconnect wasn't manual
                    if (!isManualDisconnect && reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
                        reconnectAttempts++;
                        const delay = Math.min(RECONNECT_DELAY * Math.pow(2, reconnectAttempts - 1), 30000); // Exponential backoff with max 30s
                        addLog('System', `Connection lost. Reconnecting in ${delay/1000} seconds (${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS})...`, 'source-system');
                        
                        reconnectTimeout = setTimeout(() => {
                            connect();
                        }, delay);
                    } else if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {
                        addLog('System', 'Max reconnection attempts reached. Please try again later.', 'source-system');
                    } else {
                        addLog('System', 'Disconnected', 'source-system');
                    }
                };

                socket.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    // The onclose handler will handle reconnection
                };
                
            } catch (e) {
                console.error('Error creating WebSocket:', e);
                addLog('System', `Connection error: ${e.message}`, 'source-system');
                
                if (reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
                    reconnectAttempts++;
                    const delay = Math.min(RECONNECT_DELAY * Math.pow(2, reconnectAttempts - 1), 30000);
                    addLog('System', `Reconnecting in ${delay/1000} seconds (${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS})...`, 'source-system');
                    
                    reconnectTimeout = setTimeout(() => {
                        connect();
                    }, delay);
                }
            }
        }

        connectBtn.addEventListener('click', () => {
            if (socket && (socket.readyState === WebSocket.OPEN || socket.readyState === WebSocket.CONNECTING)) {
                // Disconnect manually
                isManualDisconnect = true;
                if (reconnectTimeout) {
                    clearTimeout(reconnectTimeout);
                    reconnectTimeout = null;
                }
                if (pingInterval) {
                    clearInterval(pingInterval);
                    pingInterval = null;
                }
                socket.close();
            } else {
                // Connect
                isManualDisconnect = false;
                reconnectAttempts = 0;
                connect();
            }
        });

        messageInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault(); // Prevent form submission or newline in textarea
                const messageText = messageInput.value.trim();
                
                if (messageText === '') {
                    return; // Don't send empty messages
                }
                
                if (!socket || socket.readyState !== WebSocket.OPEN) {
                    addLog('System', 'Not connected. Please connect first.', 'source-system');
                    return;
                }
                
                try {
                    addLog('You', messageText, 'source-user');
                    
                    // The relay expects a simple payload with a "text" key
                    const payload = { text: messageText };
                    socket.send(JSON.stringify(payload));
                    
                    messageInput.value = '';
                } catch (e) {
                    console.error('Error sending message:', e);
                    addLog('System', 'Failed to send message. Trying to reconnect...', 'source-system');
                    // Try to reconnect if sending fails
                    isManualDisconnect = false;
                    connect();
                }
            }
        });

    </script>
</body>
</html>