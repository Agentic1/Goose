Parcel 1: The "Simple Service Agent" Boilerplate
This is the template for any agent that receives a request, performs a single task, and replies. It does not delegate tasks to other agents. This is perfect for connectors, simple tools, or agents like CodeCheckerAgent.
Filename: simple_service_template.py

# This is the boilerplate for a simple, non-delegating service agent.
import asyncio
from redis.asyncio import Redis
from AG1_AEtherBus.envelope import Envelope
from AG1_AEtherBus.bus import publish_envelope, build_redis_url
from AG1_AEtherBus.bus_adapterV2 import BusAdapterV2
from AG1_AEtherBus.keys import StreamKeyBuilder

# --- Agent-Specific Configuration ---
AGENT_NAME = "MySimpleService"
KEYS = StreamKeyBuilder()
AGENT_INBOX = KEYS.agent_inbox(AGENT_NAME)

class MySimpleServiceAgent:
    def __init__(self, redis_client: Redis):
        self.name = AGENT_NAME
        self.redis = redis_client
        self.adapter = BusAdapterV2(
            agent_id=self.name,
            core_handler=self.handle_bus_envelope,
            redis_client=self.redis,
            patterns=[AGENT_INBOX],
            group=self.name
        )
        print(f"[{self.name}] Initialized.")

    async def start(self):
        await self.adapter.start()
        print(f"[{self.name}] Listening on {AGENT_INBOX}")

    async def handle_bus_envelope(self, env: Envelope, redis: Redis):
        print(f"[{self.name}] Received message from: {env.agent_name}")
        
        if not env.reply_to or not env.correlation_id:
            return # Can't reply, so ignore.

        # --- YOUR AGENT'S CUSTOM LOGIC GOES HERE ---
        # 1. Extract task from envelope content
        # 2. Perform the work (e.g., call an external API, run a command)
        # 3. Create the result
        result_payload = {"status": "ok", "data": "Task completed."}
        # --- END OF CUSTOM LOGIC ---

        reply_env = Envelope(
            role="agent_response",
            agent_name=self.name,
            content=result_payload,
            correlation_id=env.correlation_id # Echo the original ID
        )
        
        await publish_envelope(redis, env.reply_to, reply_env)

# --- Standard Startup Boilerplate ---
async def main():
    redis_client = Redis.from_url(build_redis_url(), decode_responses=True)
    agent = MySimpleServiceAgent(redis_client)
    await agent.start()
    await asyncio.Future()

if __name__ == "__main__":
    asyncio.run(main())
 

 
------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------
Parcel 2: The "Advanced Agent" Boilerplate (The Stripped-Down Muse)
This is the template for any agent that needs to orchestrate or delegate tasks to other agents. This is the boilerplate for MasterCoder, MuseAgent, or your future IntelligenceOrchestrator. It includes the essential state management for handling asynchronous replies.
Filename: advanced_agent_template.py

# This is the boilerplate for a complex, delegating agent.
import asyncio
from redis.asyncio import Redis
from AG1_AEtherBus.envelope import Envelope
from AG1_AEtherBus.bus import publish_envelope, build_redis_url
from AG1_AEtherBus.bus_adapterV2 import BusAdapterV2
from AG1_AEtherBus.keys import StreamKeyBuilder
# It MUST import the shared delegate helper
from AG1_AEtherBus.helpers.delegate import delegate_task

# --- Agent-Specific Configuration ---
AGENT_NAME = "MyAdvancedAgent"
KEYS = StreamKeyBuilder()
AGENT_INBOX = KEYS.agent_inbox(AGENT_NAME)

class MyAdvancedAgent:
    def __init__(self, redis_client: Redis):
        self.name = AGENT_NAME
        self.redis = redis_client
        self.kb = StreamKeyBuilder()
        # CRITICAL: It must have its own state for tracking conversations.
        self.ongoing_conversations = {}
        self.adapter = BusAdapterV2(
            agent_id=self.name,
            core_handler=self.handle_bus_envelope,
            redis_client=self.redis,
            patterns=[AGENT_INBOX],
            group=self.name
        )
        print(f"[{self.name}] Initialized.")

    async def start(self):
        await self.adapter.start()
        print(f"[{self.name}] Listening on {AGENT_INBOX}")

    async def handle_bus_envelope(self, env: Envelope, redis: Redis):
        # First, check if this is a reply to a request we sent out.
        cid = env.correlation_id
        if cid and cid in self.ongoing_conversations:
            future = self.ongoing_conversations.pop(cid)
            if not future.done():
                future.set_result(env) # Resolve with the full envelope
            return

        # If it's not a reply, it's a new task for us to process.
        print(f"[{self.name}] Received new task from: {env.agent_name}")
        # Use asyncio.create_task to avoid blocking the handler
        asyncio.create_task(self.process_new_task(env))

    async def process_new_task(self, request_env: Envelope):
        # --- YOUR AGENT'S CUSTOM LOGIC GOES HERE ---
        # Example: Ask the DocReferenceAgent for help, then reply.
        try:
            print(f"[{self.name}] Delegating to DocReferenceAgent...")
            doc_result = await delegate_task(
                adapter=self.adapter,
                kb=self.kb,
                conversations=self.ongoing_conversations,
                sender_name=self.name,
                target_agent="DocReferenceAgent",
                content={"text": "Explain the 'self-contained agent' principle."}
            )
            final_reply_content = {"status": "ok", "docs": doc_result}
        except Exception as e:
            final_reply_content = {"status": "error", "error": str(e)}
        # --- END OF CUSTOM LOGIC ---

        if request_env.reply_to:
            reply_env = Envelope(
                role="agent_response",
                agent_name=self.name,
                content=final_reply_content,
                correlation_id=request_env.correlation_id
            )
            await publish_envelope(self.redis, request_env.reply_to, reply_env)

# --- Standard Startup Boilerplate ---
async def main():
    redis_client = Redis.from_url(build_redis_url(), decode_responses=True)
    agent = MyAdvancedAgent(redis_client)
    await agent.start()
    await asyncio.Future()

if __name__ == "__main__":
    asyncio.run(main())