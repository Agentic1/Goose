 
Developer Guide & Specification: AEtherBus v4.2
Version: 4.2
Status: Final
Objective: To establish a single, unified, non-blocking communication pattern for the entire Agentic1 ecosystem, simplifying development and increasing system stability.
1. Core Principles 
Smart Adapter, Dumb Pipe: The BusAdapterV2 is the intelligent interface for agents. It handles complex logic like loop prevention. The underlying bus (bus.py) remains a simple, reliable message transport.
Unified Asynchronous Pattern: All communication, whether agent-to-agent or agent-to-service, uses the same non-blocking "Request-Future-Reply" pattern. Blocking RPC calls are eliminated.
Predictable, User-Centric Channels: All user-facing conversations occur on dedicated, bidirectional channels, simplifying routing and debugging.
2. The Core Library: Files to Keep & Delete
To enforce this new architecture, the AG1_AEtherBus library will be streamlined.
Files to KEEP:
envelope.py (The message data model)
keys.py (The stream name generator)
bus.py (The low-level Redis functions)
agent_bus_minimal.py (The subscription/discovery logic)
bus_adapterV2.py (The primary agent interface)
Files to DELETE:
rpc.py (Legacy blocking RPC logic)
bus_adapter.py (Legacy v1 adapter)
agent_bus.py (Redundant implementation)
bus_connector.py (Unnecessary wrapper)
3. The Master Key Schema (keys.py)
The StreamKeyBuilder is the single source of truth for channel names.
A. Agent Public Inbox
Purpose: For initial contact and system-level messages.
Method: kb.agent_inbox(agent_name: str)
Example: AG1:agent:Muse1:inbox
B. User-Agent Conversation Channel
Purpose: A dedicated, bidirectional channel for a specific user-agent conversation.
Method: kb.agent_user_inbox(agent_id: str, user_id: str)
Example: AG1:agent:Muse1:user123:inbox
C. Service & Registration Streams
Purpose: For system operations and gateways.
Methods:
kb.edge_register(platform: str) -> AG1:edge:aetherdeck:register
kb.edge_inbox(service_name: str) -> AG1:edge:mcp:main:inbox
4. The Unified Communication Pattern: A Step-by-Step Guide
This is the only pattern for request-response communication.
The Caller (e.g., MuseAgent) wants a result from The Responder (e.g., OrchestratorAgent).
The Caller generates a unique conversation_id.
The Caller creates an asyncio.Future and stores it: self.ongoing_conversations[conversation_id] = future.
The Caller creates an Envelope, setting correlation_id to the conversation_id and reply_to to its own static inbox (e.g., AG1:agent:Muse1:inbox).
The Caller uses adapter.publish() to send the Envelope to the Responder's inbox.
The Caller awaits the future, pausing only that task.
The Responder receives the Envelope.
It performs its work.
It creates a reply Envelope, copying the correlation_id from the request.
It publishes the reply to the reply_to address from the request.
The Caller's main handler receives the reply, finds the Future via the correlation_id, and calls future.set_result(reply_content). The waiting task resumes.
5. ASCII Flow Diagram: User Interaction
This diagram shows how the "Per-User Inbox" and "Smart Adapter" work together.
+-----------------+   1. User "user123" connects.
| AetherDeck UI   |
+-----------------+
        |
        v
+-----------------------------+   2. Relay determines channel: "AG1:agent:Muse1:user123:inbox"
| aetherdeck_relay_handler    |   3. Relay's adapter (ID="Relay") subscribes to this channel.
| (agent_id="Relay")          |   4. Relay sends "session_start" to Muse1's public inbox.
+--------------+--------------+
               |
               | (Bus: session_start to AG1:agent:Muse1:inbox)
               v
+--------------+--------------+   5. Muse1 receives session_start.
|         MuseAgent           |   6. Muse1's adapter (ID="Muse1") subscribes to
|      (agent_id="Muse1")     |      "AG1:agent:Muse1:user123:inbox".
+-----------------------------+

       --- Conversation Begins ---

+-----------------+   7. User types "Hello"  +-----------------------------+
| AetherDeck UI   |------------------------->| aetherdeck_relay_handler    |
+-----------------+                          +--------------+--------------+
                                                            |
                                                            | 8. Relay publishes "Hello" to the
                                                            |    SHARED channel, with header
                                                            |    "x-sender-id": "Relay"
                                                            |
        +----------[ AG1:agent:Muse1:user123:inbox ]<--------+
        |
+-------v------------------------+             +-------------v---------------+
| 9a. MuseAgent's adapter        |             | 9b. Relay's adapter         |
|     receives. Sender is NOT    |             |     receives. Sender IS     |
|     "Muse1" -> PROCESSES.      |             |     "Relay" -> IGNORES.     |
+-------+------------------------+             +-----------------------------+
        |
        | 10. MuseAgent replies, publishing to the SAME channel
        |     with header "x-sender-id": "Muse1"
        |
        +----------[ AG1:agent:Muse1:user123:inbox ]--------->
        |
+-------v------------------------+             +-------------v---------------+
| 11a. Relay's adapter receives. |             | 11b. MuseAgent's adapter    |
|      Sender is NOT "Relay" ->  |             |      receives. Sender IS    |
|      PROCESSES and updates UI. |             |      "Muse1" -> IGNORES.    |
+--------------------------------+             +-----------------------------+
Use code with caution.
6. Developer Quickstart: Building a v4.2-Compliant Agent
This is the template for all new agents.
import asyncio
import uuid
from redis.asyncio import Redis
from AG1_AEtherBus.bus_adapterV2 import BusAdapterV2
from AG1_AEtherBus.envelope import Envelope
from AG1_AEtherBus.keys import StreamKeyBuilder

class MyNewAgent:
    def __init__(self, agent_id: str, redis_client: Redis):
        self.name = agent_id
        self.redis = redis_client
        self.kb = StreamKeyBuilder()
        self.ongoing_conversations = {}

        # Every agent gets a BusAdapter.
        self.adapter = BusAdapterV2(
            agent_id=self.name,
            core_handler=self.handle_bus_envelope,
            redis_client=self.redis,
            patterns=[self.kb.agent_inbox(self.name)] # Listen on main inbox
        )

    async def start(self):
        await self.adapter.start()
        print(f"[{self.name}] is online.")

    # This is the single entry point for all incoming messages.
    async def handle_bus_envelope(self, env: Envelope, redis: Redis):
        # Check if it's a reply to a request this agent sent out.
        cid = env.correlation_id
        if cid and cid in self.ongoing_conversations:
            future = self.ongoing_conversations.pop(cid)
            if not future.done():
                future.set_result(env.content)
            return

        # Otherwise, it's a new request for this agent to process.
        print(f"[{self.name}] Received new request: {env.content}")
        # ... do work here ...
        
        # Example: sending a reply
        if env.reply_to:
            reply_content = {"text": f"I have processed your request."}
            reply_env = Envelope(
                content=reply_content,
                correlation_id=cid, # Echo back the correlation_id
                # ... other fields ...
            )
            await self.adapter.publish(env.reply_to, reply_env)

    # Example of a function that calls another service.
    async def ask_another_agent(self, target_inbox: str, question: str):
        conversation_id = str(uuid.uuid4())
        future = asyncio.get_running_loop().create_future()
        self.ongoing_conversations[conversation_id] = future

        request_env = Envelope(
            content={"text": question},
            correlation_id=conversation_id,
            reply_to=self.kb.agent_inbox(self.name) # Reply to my static inbox
        )

        await self.adapter.publish(target_inbox, request_env)
        
        print(f"[{self.name}] Asking '{question}' and waiting for reply...")
        result = await asyncio.wait_for(future, timeout=30.0)
        print(f"[{self.name}] Got reply: {result}")
        return result